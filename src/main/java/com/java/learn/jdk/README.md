######基础面试题
#计算网络基础常识

###进程与线程

#####进程与线程的区别和联系：

    1、进程是系统资源分配的最小单位，线程是程序执行的最小单位；
    2、进程使用独立的数据空间，而线程共享进程的数据空间。

#####线程的调度算法：
    
    1、时间片轮转调度
    2、先来先服务调度
    3、优先级调度
    4、多级反馈队列调度以及高响应比优先调度。

#####线程上下文切换及代价


#####CPU上下文切换
    1、保存上一任务的CPU上下文（寄存器和程序计数器）
    2、加载新任务的上下文到寄存器和计数器
    3、跳转到程序计数器的位置，执行任务
   
   
#####进程间的通讯 IPC
    1、管道  半双工  数据单项流动   分为无名和有名，前者只能在父子进程间进行传递，后者无限制     传输效率低
    2、信号量  控制资源，防止其他进程访问资源，用于进程或线程内状态同步
    3、信号    通知进程接收某个已经发生的事件
    4、消息队列      消息链表，克服了信号的信息量少，以及1只能传递字节流，可以传递格式化的数据
    5、共享内存     映射一块内存供其它的进程共享
    6、套接字（Socket）   跨主机通过网络进行传递
####
  
###Linux


#####Linux常用命令


#####内存屏障、指令乱序、分支预测、NUMA 与 CPU 亲和性    （扩展）


#####内存分页管理与 Swap 机制、任务队列与 CPU Load （不常考）

####

##计算机网络
###4/7层网络模型
    OSI七层
    1、物理层   硬件接口  传输数据比特
    2、数据链路层  控制协议  帧
    3、网络层   路由选址    产生了IP协议
    4、传输层   保证传输的质量，防止丢包
    5、会话层   自动收发包、自动选址  建立会话
    6、表示层   数据格式转化
    7、应用层   应用程序与网络的接口
    
    
    TCP/IP四层
    1、网络接口层 物理层+数据链路层
    2、网络层
    3、传输层
    4、应用层   会话+表示+应用
    
###TCP协议
#####特点
    1、基于链接  建立连接后再传输数据
    2、字节流传输 基于字节流而不是报文，保证了顺序和完整
    3、双工   建立双向连接
    4、流量控制  通过滑动窗口控制流量
    5、防止重传  拥塞算法
#####三握手和四次挥手
######三次握手
    1、client:   SYN   SYN-SENT
    2、server:   ACK+SYN   SYN-RCVD
    3、client:   ACK    ESTABLISHED
    4、server：  ESTABLISHED
######四次挥手
    1、client:   FIN     FIN-WAIT-1
    2、server:   ACK     CLOSE_WAIT
    3、client:   __      FIN-WAIT-2
    4、server：  FIN     LAST-ACK
    5、client:   ACK     TIME-WAIT   (2个最大报文生存时间)
    6、server:   __      CLOSE
    7、client:   __      CLOSE
######为什么要等到两个最大报文生存时间再关闭
    1、保证全双工连接能够安全关闭 避免服务端没有收到ACK
    2、保证这次连接的重复数据段从网络消失
    
######TCP 的报文状态标志与链接状态
######Nagel算法和 ACK 延迟
######Keepalive
######滑动窗口和流量控制


####UDP协议

####HTTP协议

####

###设计模式
####常用的设计模式
#####单例模式   
    1、饿汉式   无线程安全问题
    2、懒汉式   
        双重检验+Volititle
    3、单例注册表 (Spring创建单例的Bean)

#####工厂模式
    Spring创建Bean，BeanFactory
    
#####代理模式
    静态代理
    动态代理： Spring创建Bean
        jdk动态代理
        cglib动态代理
#####责任链模式
    Netty消息处理的方式
    
#####适配器模式
    log4j
#####观察者模式
    gRPC
#####构造者模式
    创建对象
#####模板模式
#####策略模式

####

###java语言
####常用集合
#####HashMap
    1、是什么   K-V非线程安全容器
    2、数据结构  1.7之前数组+单链表     1.8之后数组+单链表+红黑树
    3、负载因子及扩容机制
    4、为什么容量是2的倍数
    5、头插法和尾插法

#####ConcurrentHashMap
    1、


####并发包
####版本差异
#####1.8
    1、Lambda表达式和接口式函数
    2、StreamApi
    3、接口默认方法
    4、元空间替换永久代，作为JVM以外内存进行管理
####动态代理反射
####数据类型
####对象引用
    1、强引用   有引用不会被回收
    2、软引用   有引用且内存不足被回收   适合当缓存
    3、弱引用   只要垃圾回收就会被回收掉
    4、虚引用   不会对对象的生命周期产生影响，用于对象回收时的通知
    
    ThreadLocal为什么用弱引用
####注解处理机制
#####注解的作用
    1、生成文档，通过代码里标识的元数据生成javadoc文档。
    2、编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。
    3、编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。
    4、运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例

###JVM
####类加载
#####双亲委派模型
    类加载器在进行加载类的时候，会先委托给父类加载器进行加载，然后再自己加载
    为了避免同一个类不同的类加载加载造成的混乱
#####类加载
    1、bootstrap JAVA_HOME下的核心类库
    2、ExtClassLoader    JAVA_HOME下lib/ext下的扩展类库
    3、AppClassLoader    ClassPath下的jar
    4、自定义的ClassLoader   


####JVM内存模型
#####
    1、虚拟机栈  执行方法时将方法中的信息保存至虚拟机栈中
    2、本地方法栈
    3、程序计数器
    4、堆
    5、方法区

####JMM java内存模型
####JVM性能优化

####编译器优化
####执行模式



###并发与多线程
####并发编程三要素
    1、原子性   线程切换带来原子性问题 synchronized、lock
    2、可见性   缓存带来    synchronized,volatile
    3、有序性   编译器的优化  volatile
####并发编程的优缺点
    优点：
        1、充分调动CPU
        2、提升并发能力和性能
    缺点：
        1、编程复杂度增加：线程安全、死锁、内存泄漏、上下文切换
####死锁
    1、
####线程状态及转换
####同步与互斥
####线程间的通讯
####常用的并发包工具类
####机制
####线程池

###数据结构与算法
####数据结构
#####

####算法
#####复杂度
#####常用算法思路
#####字符串匹配
#####排序
#####查找

###工具类
####


