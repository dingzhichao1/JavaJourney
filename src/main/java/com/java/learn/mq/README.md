###消息队列
####总述
#####概念：传递消息的队列
#####应用：
    1、异步
    2、解耦
    3、削峰
    4、数据分发：发布订阅模式

#####消息丢失问题
    1、生产者丢失   通过事务（kafka、RabbitMQ）、confirm（RabbitMQ）
    2、对列丢失     持久化（RabbitMQ、Kafka）+ACK确认
    3、消费者丢失   将自动确认改为手动确认
#####如何保证高可用（高可用集群，不同的MQ采用不同的解决方案）
    1、Kafka采用多副本Partition
    2、RabbitMQ  简单集群（不保证高可用）、镜像集群（保证高可用）
    
    
#####持久化


#####消息积压（从生产者和消费者两个方面）原因+解决方案
    1、生产者速率增加：增加消费者的实例、服务降级（减少生成）、消息丢弃
    2、生产者速率没有增加：检查消费者消费问题-重复消费、死锁等等
    













#####常用的消息队列
######Apache Kafka
    1、Scala
    2、Zookeeper 维护Offset偏移量 集群下的 Leader 选举  节点管理等
    3、高吞吐  持久化   顺序写入   零拷贝
    4、支持数据埋点    日志收集和计算
    
######Apache RocketMQ
    1、稳定性   可靠性   持久化
    2、顺序一致性
    3、电商
######Apache RabbitMQ
    1、功能全面  支持多种协议
    2、顺序传输  优先队列
    3、
    
######消费模式
    1、点对点
    2、发布订阅
 
 
 
 
 
 
 
 
    
####Kafka
#####kafka的系统角色
    1、Producer  生产者
    2、Consumer  消费者
    3、Broker    服务器节点
    4、Topic 对消息进行归类
    5、ConsumerGroup 消费者分组，每个消费者分在一个单独的组里
#####消费模式
    发布订阅
#####消费时序性
    1、分布式时钟问题   生产者、消费者和队列存储的时钟不一致
    2、集群问题  生产者和消费者是集群，时钟无法同步
    3、消息重传  重传会破坏消息的顺序
    4、网络及内部并发
      
    解决方案：kafka保证了单分区的消息顺序，有消息顺序需求的需要发送到同一个Partition
    特殊场景：发送失败导致的重新发送，max.in.flight.requests.per.connection=1
    

#####重复消费问题（幂等处理）
######消息投递语义   (规范)
    1、AtMostOnce    不会重，只会丢
    2、AtLeastOnce   不会丢，但是会重
    3、ExactlyOnce   理论上，几乎难以实现
#######幂等性
    1、业务方的幂等处理
    2、数据库的幂等处理（通过设置唯一主键）
    3、部分天然幂等性的业务可以多次重试
    4、设置唯一的消费ID,分布式锁